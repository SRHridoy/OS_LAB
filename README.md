# OS Lab Codes

এই রিপোজিটরিতে অপারেটিং সিস্টেমের বিভিন্ন মৌলিক অ্যালগরিদমের C++ ইমপ্লিমেন্টেশন রয়েছে।

## সূচিপত্র

1.  [CPU শিডিউলিং অ্যালগরিদম](#1-cpu-শিডিউলিং-অ্যালগরিদম)
    *   [First-Come, First-Served (FCFS)](#11-first-come-first-served-fcfs)
    *   [Shortest Job First (SJF) - Non-Preemptive](#12-shortest-job-first-sjf---non-preemptive)
    *   [Shortest Job First (SJF) - Preemptive](#13-shortest-job-first-sjf---preemptive)
    *   [Round Robin](#14-round-robin)
    *   [Priority Scheduling - Non-Preemptive](#15-priority-scheduling---non-preemptive)
2.  [ডেডলক এড়ানো](#2-ডেডলক-এড়ানো)
    *   [Banker's Algorithm](#21-bankers-algorithm)
3.  [মেমরি ম্যানেজমেন্ট](#3-মেমরি-ম্যানেজমেন্ট)
    *   [First Fit, Best Fit, Worst Fit](#31-first-fit-best-fit-worst-fit)
4.  [পেজ রিপ্লেসমেন্ট অ্যালগরিদম](#4-পেজ-রিপ্লেসমেন্ট-অ্যালগরিদম)
    *   [FIFO Page Replacement](#41-fifo-page-replacement)
    *   [Optimal Page Replacement](#42-optimal-page-replacement)
    *   [Least Recently Used (LRU)](#43-least-recently-used-lru)
    *   [Most Recently Used (MRU)](#45-most-recently-used-mru)

---

## 1. CPU শিডিউলিং অ্যালগরিদম

### 1.1 First-Come, First-Served (FCFS)

**থিওরি:**
FCFS একটি নন-প্রিemptive শিডিউলিং অ্যালগরিদম। এই পদ্ধতিতে, যে প্রসেস প্রথমে আসে, তাকেই প্রথমে সিপিইউ বরাদ্দ করা হয়। এটি সবচেয়ে সহজ শিডিউলিং অ্যালগরিদম।

**কোড ব্যাখ্যা:**
কোডটি প্রসেসগুলোর arrival time এবং burst time ইনপুট নেয়। এরপর FCFS অ্যালগরিদম অনুযায়ী waiting time এবং turnaround time গণনা করে এবং গড় মান প্রদর্শন করে।

### 1.2 Shortest Job First (SJF) - Non-Preemptive

**থিওরি:**
এই নন-প্রিemptive অ্যালগরিদমে, যে প্রসেসের burst time সবচেয়ে কম, তাকে প্রথমে সিপিইউ দেওয়া হয়। যদি দুটি প্রসেসের burst time সমান হয়, তবে FCFS ব্যবহার করা হয়।

**কোড ব্যাখ্যা:**
কোডটি প্রসেসগুলোকে তাদের burst time অনুযায়ী সাজায় এবং তারপর waiting time ও turnaround time গণনা করে।

### 1.3 Shortest Job First (SJF) - Preemptive

**থিওরি:**
এটি SJF-এর প্রিemptive সংস্করণ। এখানে, যদি কোনো নতুন প্রসেসের burst time বর্তমানে চলমান প্রসেসের বাকি burst time-এর চেয়ে কম হয়, তাহলে সিপিইউ নতুন প্রসেসকে দেওয়া হয়।

**কোড ব্যাখ্যা:**
কোডটি প্রতি একক সময়ে চেক করে যে কোনো নতুন প্রসেস এসেছে কিনা যার burst time চলমান প্রসেসের চেয়ে কম। এর উপর ভিত্তি করে এটি প্রসেস সুইচ করে এবং waiting time ও turnaround time গণনা করে।

### 1.4 Round Robin

**থিওরি:**
Round Robin একটি প্রিemptive অ্যালগরিদম। এখানে প্রতিটি প্রসেসকে একটি নির্দিষ্ট সময় (time quantum) পর্যন্ত সিপিইউ ব্যবহার করতে দেওয়া হয়। সময় শেষ হলে, প্রসেসটি ready queue-এর শেষে চলে যায় এবং পরের প্রসেস সিপিইউ পায়।

**কোড ব্যাখ্যা:**
কোডটি একটি time quantum ইনপুট নেয়। এটি একটি queue ব্যবহার করে Round Robin অ্যালগরিদম প্রয়োগ করে এবং প্রতিটি প্রসেসের জন্য waiting time ও turnaround time গণনা করে।

### 1.5 Priority Scheduling - Non-Preemptive

**থিওরি:**
এই নন-প্রিemptive অ্যালগরিদমে, প্রতিটি প্রসেসের একটি priority থাকে। যে প্রসেসের priority সবচেয়ে বেশি (সাধারণত ছোট সংখ্যা মানে বেশি priority), তাকে আগে সিপিইউ দেওয়া হয়।

**কোড ব্যাখ্যা:**
কোডটি প্রসেসগুলোকে তাদের priority অনুযায়ী সাজায় এবং তারপর waiting time ও turnaround time গণনা করে।

---

## 2. ডেডলক এড়ানো

### 2.1 Banker's Algorithm

**থিওরি:**
Banker's Algorithm একটি ডেডলক এড়ানোর অ্যালগরিদম। এটি সিস্টেমের অবস্থা বিশ্লেষণ করে নিশ্চিত করে যে সিস্টেমটি কখনও unsafe state-এ যাবে না, যার ফলে ডেডলক হতে পারে। এটি একটি safe sequence খুঁজে বের করার চেষ্টা করে।

**কোড ব্যাখ্যা:**
কোডটি সিস্টেমের মোট রিসোর্স, প্রসেসগুলোর সর্বোচ্চ প্রয়োজন এবং বর্তমানে বরাদ্দ করা রিসোর্স ইনপুট নেয়। এরপর এটি need matrix গণনা করে এবং একটি safe sequence খুঁজে বের করার চেষ্টা করে।

---

## 3. মেমরি ম্যানেজমেন্ট

### 3.1 First Fit, Best Fit, Worst Fit

**থিওরি:**
এগুলো মেমরি ব্লকে প্রসেস বরাদ্দ করার তিনটি কৌশল:
*   **First Fit:** মেমরির প্রথম যে ব্লকটি প্রসেসের জন্য যথেষ্ট বড়, সেখানেই বরাদ্দ করা হয়।
*   **Best Fit:** সবচেয়ে ছোট যে ব্লকটি প্রসেসের জন্য যথেষ্ট, সেখানে বরাদ্দ করা হয়।
*   **Worst Fit:** সবচেয়ে বড় যে ব্লকটি পাওয়া যায়, সেখানে বরাদ্দ করা হয়।

**কোড ব্যাখ্যা:**
কোডটি মেমরি ব্লক এবং প্রসেসের সাইজ ইনপুট নেয়। এরপর তিনটি অ্যালগরিদম প্রয়োগ করে দেখায় কোনটি কোন ব্লকে প্রসেস বরাদ্দ করছে।

---

## 4. পেজ রিপ্লেসমেন্ট অ্যালগরিদম

### 4.1 FIFO Page Replacement

**থিওরি:**
First-In, First-Out (FIFO) অ্যালগরিদমে, যে পেজটি প্রথমে মেমরিতে আসে, পেজ ফল্ট হলে সেই পেজটিই প্রথমে প্রতিস্থাপন করা হয়।

**কোড ব্যাখ্যা:**
কোডটি একটি reference string এবং ফ্রেমের সংখ্যা ইনপুট নেয়। এটি একটি queue ব্যবহার করে FIFO অ্যালগরিদম প্রয়োগ করে এবং মোট পেজ ফল্টের সংখ্যা গণনা করে।

### 4.2 Optimal Page Replacement

**থিওরি:**
এই অ্যালগরিদমে, যে পেজটি ভবিষ্যতে সবচেয়ে দেরিতে ব্যবহৃত হবে, সেই পেজটি প্রতিস্থাপন করা হয়। এটি সর্বনিম্ন পেজ ফল্ট নিশ্চিত করে, তবে বাস্তবায়ন করা কঠিন কারণ ভবিষ্যতের reference জানা প্রয়োজন।

**কোড ব্যাখ্যা:**
কোডটি reference string এবং ফ্রেম সংখ্যা ইনপুট নেয়। প্রতিটি পেজ ফল্টের সময়, এটি ফ্রেমের পেজগুলোকে ভবিষ্যতের reference string-এর সাথে তুলনা করে এবং সবচেয়ে দেরিতে ব্যবহৃত পেজটি খুঁজে বের করে প্রতিস্থাপন করে।

### 4.3 Least Recently Used (LRU)

**থিওরি:**
LRU অ্যালগরিদমে, যে পেজটি সবচেয়ে কম সময় ধরে ব্যবহৃত হয়েছে (least recently used), পেজ ফল্ট হলে সেই পেজটি প্রতিস্থাপন করা হয়।

**কোড ব্যাখ্যা:**
কোডটি reference string এবং ফ্রেম সংখ্যা ইনপুট নেয়। এটি প্রতিটি পেজের সর্বশেষ ব্যবহারের সময় ট্র্যাক করে এবং পেজ ফল্টের সময় সবচেয়ে পুরনো ব্যবহৃত পেজটি প্রতিস্থাপন করে।

### 4.5 Most Recently Used (MRU)

**থিওরি:**
MRU অ্যালগরিদমে, যে পেজটি সম্প্রতি সবচেয়ে বেশি ব্যবহৃত হয়েছে (most recently used), পেজ ফল্ট হলে সেই পেজটি প্রতিস্থাপন করা হয়।

**কোড ব্যাখ্যা:**
কোডটি reference string এবং ফ্রেম সংখ্যা ইনপুট নেয়। এটি প্রতিটি পেজের সর্বশেষ ব্যবহারের সময় ট্র্যাক করে এবং পেজ ফল্টের সময় সবচেয়ে নতুন ব্যবহৃত পেজটি প্রতিস্থাপন করে।
